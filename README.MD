TUGAS 1
Membuat sebuah README.md yang berisi tautan menuju aplikasi PWS yang sudah di-deploy, serta jawaban dari beberapa pertanyaan berikut.
- https://khayra-tazkiya-miufootballshop.pbp.cs.ui.ac.id/

- 1. Jelaskan bagaimana cara kamu mengimplementasikan checklist di atas secara step-by-step (bukan hanya sekadar mengikuti tutorial).
Jawaban : 
    1. membuat proyek django baru
    saya menyiapkan folder kerja, membuat lingkungan virtual (virtual environment), memasang django, lalu menjalankan perintah startproject. saya memakai underscore pada nama paket proyek karena nama paket harus berupa identifier python yang sah.

    mkdir miufootball-shop
    cd miufootball-shop
    python3 -m venv .venv
    source .venv/bin/activate
    python -m pip install django
    python -m django startproject miufootball_shop .

    struktur awal:
    manage.py
    miufootball_shop/
    __init__.py
    settings.py
    urls.py
    wsgi.py
    asgi.py

    2. membuat aplikasi bernama main
    saya menambahkan aplikasi utama bernama main dan mendaftarkannya ke proyek.

    python manage.py startapp main
    aktifkan di miufootball_shop/settings.py:

    INSTALLED_APPS = [
        # aplikasi bawaan django …
        'main',
    ]

    3. routing proyek agar dapat menjalankan aplikasi main
    saya membuat berkas urls khusus untuk aplikasi main, lalu menghubungkannya dari urls proyek.


    main/urls.py:
from django.urls import path
from main.views import show_main

app_name = 'main'

urlpatterns = [
    path('', show_main, name='show_main'),
]


    4. membuat model product dengan 6 atribut wajib
    saya mendefinisikan model product sesuai ketentuan: name, price, description, thumbnail, category, is_featured.


    main/models.py:
    from django.db import models
    
    class Product(models.Model):
        name = models.CharField(max_length=200)
        price = models.IntegerField()
        description = models.TextField()
        thumbnail = models.URLField(default="https://via.placeholder.com/150")
        category = models.CharField(max_length=100)
        is_featured = models.BooleanField(default=False)
        
        # opsional: stock dan brand
        stock = models.IntegerField(default=0)
        brand = models.CharField(max_length=100, blank=True)
        
        def __str__(self):
            return self.name

    5. membuat dan menerapkan migrasi basis data
    setiap perubahan pada model harus dimigrasikan agar skema basis data sesuai dengan kode.


    python manage.py makemigrations main
    python manage.py migrate

    6. membuat fungsi pada views.py dan templat html

    main/views.py:
    from django.shortcuts import render


# Create your views here.
    from django.shortcuts import render
    
    def show_main(request):
        context = {
            'app_name': 'MiuFootball Shop',
            'name': '2406428876 - Khayra Tazkiya',
            'class_name': 'PBP D'
        }
        return render(request, 'main.html', context)

   
    main/templates/main.html:
    <!DOCTYPE html>
    <html>
    <head>
        <title>MiuFootball Shop</title>
        <style>
            body {
            font-family: Comic Sans, Helvetica, sans-serif; 
            }
            h1 {
            font-family: "Courier New", monospace; 
            }
            h5 {
                font-family: "Courier New", monospace; 
                font-style: italic;            
            }
            p {
            font-size: 19px; 
            }
        </style>
    </head>
    <body>
        <h1>Welcome to {{ app_name }}!</h1>
        <h5>Gear up for glory—kits, boots, and pro training gear in one place.</h5>
        <p>Made by: {{ name }}</p>
        <p>Class: {{ class_name }}</p>
    </body>
    </html>

    7. memastikan routing urls.py aplikasi main ke fungsi pada views.py
    langkah ini sudah dilakukan pada butir 3 (path "" dipetakan ke fungsi home). jika halaman akar (/) belum mengarah ke home, pastikan include("main.urls") sudah ada di urls proyek.

    8. menguji secara lokal
    python manage.py runserver

    buka http://127.0.0.1:8000/ dan pastikan nama aplikasi, nama, serta kelas tampil.

    9. melakukan deployment ke pws
    saya menyiapkan variabel lingkungan (environment variable) untuk pws, menambahkan domain pws ke allowed_hosts, lalu mendorong (push) kode ke remote pws.


    pengaturan minimal di miufootball_shop/settings.py:
"""
Django settings for miufootball_shop project.

Generated by 'django-admin startproject' using Django 5.2.6.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from pathlib import Path
import os
from dotenv import load_dotenv
# Load environment variables from .env file
load_dotenv()

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-zf5mefl9-bhau0a5%2!)q)2cam1)j!r-o7n*-5@)fvlom3_tna'

# SECURITY WARNING: don't run with debug turned on in production!
PRODUCTION = os.getenv('PRODUCTION', 'False').lower() == 'true'
DEBUG = True

ALLOWED_HOSTS = ["localhost", "127.0.0.1", "khayra-tazkiya-miufootballshop.pbp.cs.ui.ac.id"]


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'main',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'miufootball_shop.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'miufootball_shop.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

# Database configuration
if PRODUCTION:
    # Production: gunakan PostgreSQL dengan kredensial dari environment variables
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.postgresql',
            'NAME': os.getenv('DB_NAME'),
            'USER': os.getenv('DB_USER'),
            'PASSWORD': os.getenv('DB_PASSWORD'),
            'HOST': os.getenv('DB_HOST'),
            'PORT': os.getenv('DB_PORT'),
            'OPTIONS': {
                'options': f"-c search_path={os.getenv('SCHEMA', 'public')}"
            }
        }
    }
else:
    # Development: gunakan SQLite
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': BASE_DIR / 'db.sqlite3',
        }
    }


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


    contoh .env (pengembangan lokal):
    PRODUCTION=False

    contoh .env.prod (untuk pws):
    DB_NAME=…
    DB_HOST=…
    DB_PORT=…
    DB_USER=…
    DB_PASSWORD=…
    SCHEMA= tugas_individu
    PRODUCTION=True

    langkah dorong ke pws (setelah menambahkan remote pws dari dasbor pws):
    git add .
    git commit -m "inisialisasi proyek, app main, model Product, view home"
    git push origin master
    git push pws master

    bila perlu jalankan perintah manajemen dari konsol pws:
    python manage.py migrate


2. Buatlah bagan yang berisi request client ke web aplikasi berbasis Django beserta responnya dan jelaskan pada bagan tersebut kaitan antara urls.py, views.py, models.py, dan berkas html.
Jawaban:
    https://docs.google.com/document/d/1GNVq6tedFB3UAIGI46Pag97Xna98M94PoD7dfenFSe8/edit?usp=sharing

3. Jelaskan peran settings.py dalam proyek Django!
Jawaban:
    settings.py menyimpan konfigurasi global proyek Django: daftar aplikasi (INSTALLED_APPS), middleware, pengaturan database, template, static files, SECRET_KEY, DEBUG, ALLOWED_HOSTS, internationalization, time zone, hingga konfigurasi pihak ketiga. Intinya, ini “panel kontrol” proyek.

4. Bagaimana cara kerja migrasi database di Django?
Jawaban:
    1. Definisikan/ubah model di models.py.

    2. Jalankan python manage.py makemigrations → Django membaca perubahan model dan membuat berkas migrasi (skrip perubahan skema).

    3. Jalankan python manage.py migrate → menerapkan berkas migrasi ke database (membuat tabel/kolom/constraint).

    4. Django menjaga riwayat migrasi, sehingga kamu bisa melacak, menerapkan, atau rollback (ke versi tertentu) bila diperlukan.

5. Menurut Anda, dari semua framework yang ada, mengapa framework Django dijadikan permulaan pembelajaran pengembangan perangkat lunak?
Jawaban:
    - Productive & opinionated: banyak fitur bawaan (admin, ORM, auth, form) → cepat melihat hasil nyata.

    - Arsitektur jelas (MVT): memudahkan memahami pemisahan concern data–logika–presentasi.

    - Dokumentasi & ekosistem kuat: mudah dipelajari dan dibantu komunitas.

    - Aman & andal: proteksi XSS/CSRF/SQLi bawaan → praktik baik sejak awal.

    - Skalabel: dari tugas kuliah hingga aplikasi produksi serius—sekali belajar, manfaat panjang.


6. Apakah ada feedback untuk asisten dosen tutorial 1 yang telah kamu kerjakan sebelumnya?
Jawaban: belum ada

---------------------------------------------------------------------------------------------------
TUGAS 3
1. Jelaskan mengapa kita memerlukan data delivery dalam pengimplementasian sebuah platform?
    Memisahkan lapisan sistem (decoupling) sehingga frontend dan backend dapat berkembang mandiri tanpa saling mengganggu.

    Memungkinkan interoperabilitas dengan klien dan layanan lain (web, mobile, otomatisasi, analitik) melalui format baku yang mudah diproses mesin.

    Meningkatkan efisiensi: muatan respons terstruktur mudah di-cache, difilter, dan dipaginasi.

    Mendukung skalabilitas dan pemakaian ulang: satu sumber data dapat dilayani ke banyak konsumen.

    Memperkuat kendali dan keamanan: pembatasan kolom, otorisasi, pembatasan laju, serta pencatatan dapat dilakukan pada lapisan API.

2. Menurutmu, mana yang lebih baik antara XML dan JSON? Mengapa JSON lebih populer dibandingkan XML?
   JSON

    Ringkas dan mudah dibaca, langsung memetakan objek dan larik pada banyak bahasa pemrograman, serta dekat dengan ekosistem JavaScript.

    Umumnya lebih cepat diuraikan (parsing) dan ukuran muatannya lebih kecil untuk kebutuhan API modern.

    XML

    Kaya fitur (namespace, atribut, serta validasi skema/XSD) dan sesuai untuk dokumen kompleks atau integrasi bergaya enterprise.

    Kesimpulan
    Tidak ada yang mutlak lebih baik; pemilihan bergantung konteks. JSON lebih populer karena kesederhanaan, efisiensi muatan, dan dukungan luas pada pengembangan API web. 

3. Jelaskan fungsi dari method is_valid() pada form Django dan mengapa kita membutuhkan method tersebut?
    -Menjalankan seluruh validasi bidang dan tingkat formulir (termasuk metode clean_<field>() dan clean()).

    -Jika valid, menyediakan cleaned_data yang telah dibersihkan dan bertipe benar; pada ModelForm dapat langsung disimpan melalui form.save().

    -Menjaga integritas dan keamanan data di sisi server, tidak hanya mengandalkan validasi di sisi klien.
    Contoh pola dasar:
    def create_product(request):
    if request.method == "POST":
    form = ProductForm(request.POST)
    if form.is_valid():
    obj = form.save()
    return redirect("product_detail", pk=obj.pk)
    else:
    form = ProductForm()
    return render(request, "form.html", {"form": form})


4.  Mengapa kita membutuhkan csrf_token saat membuat form di Django? Apa yang dapat terjadi jika kita tidak menambahkan csrf_token pada form Django? Bagaimana hal tersebut dapat dimanfaatkan oleh penyerang?

    csrf_token melindungi dari serangan Cross-Site Request Forgery (CSRF), yaitu kondisi ketika pengguna yang sedang masuk (login) digiring untuk mengirim permintaan sah ke situs Anda dari domain lain tanpa sepengetahuannya.

    Tanpa csrf_token, penyerang dapat membuat halaman yang secara otomatis mengirim formulir ke aplikasi Anda menggunakan kuki sesi korban, sehingga tindakan penting (mengubah data, membuat transaksi, menghapus entri) dapat terjadi tanpa persetujuan.

    Token acak yang disisipkan pada formulir dan diverifikasi server memastikan setiap permintaan perubahan keadaan hanya valid jika berasal dari halaman sah milik aplikasi.

5. Jelaskan bagaimana cara kamu mengimplementasikan checklist di atas secara step-by-step (bukan hanya sekadar mengikuti tutorial).

    1. Menyiapkan model dan formulir

    Pastikan model telah tersedia; buat ModelForm untuk memudahkan pembuatan entitas baru dan memastikan validasi terpusat.

    2. Menulis views halaman

    Daftar: menampilkan seluruh entitas dalam tabel serta menyediakan tombol tambah dan detail.

    Tambah: menampilkan formulir pada GET, memvalidasi dengan is_valid() pada POST, lalu menyimpan dan mengalihkan ke halaman detail.

    Detail: menampilkan informasi lengkap satu entitas.

    3. Menulis views data delivery

    Menyediakan endpoint JSON dan XML untuk seluruh data.

    Menyediakan endpoint JSON dan XML berdasarkan id dengan tetap mengembalikan QuerySet agar kompatibel dengan serializer Django.

    4.  Menyusun rute (URL routing)

    Menetapkan jalur untuk daftar, tambah, detail, serta empat endpoint data delivery (JSON/XML untuk semua dan per id).

    Mengikutsertakan (include) berkas urls aplikasi pada urls proyek.

    5. Menyusun templat

    Membuat templat dasar (layout), templat daftar (tabel dan tombol), templat formulir (dengan csrf_token), dan templat detail.

    6. Validasi dan peningkatan kegunaan

    Memastikan impor yang benar, penerapan csrf_token, serta, bila perlu, pemakaian penataan angka/harga melalui pustaka bawaan Django.

    7. Pengujian

    Menguji alur tambah–detail–daftar di peramban, lalu mengakses keempat endpoint data delivery.

    Menggunakan Postman untuk memverifikasi kode status dan isi respons, serta mendokumentasikannya.

    8. Dokumentasi dan distribusi

    Menambahkan uraian teknis dan jawaban pertanyaan pada berkas README, lalu melakukan komit dan dorong (push) ke repositori.

6. Apakah ada feedback untuk asdos di tutorial 2 yang sudah kalian kerjakan?
belum ada 


---------------------------------------------------------------------------------------------------
Tugas 4
1. Apa itu Django AuthenticationForm? Jelaskan juga kelebihan dan kekurangannya.

    AuthenticationForm adalah form bawaan Django yang digunakan untuk login, lengkap dengan field username dan password, serta validasi otomatis.

    Kelebihan:
    Hemat waktu, tidak perlu membuat form manual.
    Terintegrasi langsung dengan sistem autentikasi Django.
    Keamanan password sudah ditangani.

    Kekurangan:
    Tidak fleksibel untuk login dengan field khusus (misalnya email).
    Tampilan default sangat sederhana sehingga biasanya perlu dikustomisasi.


2. Apa perbedaan antara autentikasi dan otorisasi? Bagaiamana Django mengimplementasikan kedua konsep tersebut?
    Autentikasi: verifikasi identitas (apakah user valid).
    Otorisasi: pengecekan hak akses (apa yang boleh dilakukan user).

    Pada Django:
    Autentikasi: authenticate(), login(), AuthenticationForm.
    Otorisasi: permissions, groups, decorator @login_required.

3. Apa saja kelebihan dan kekurangan session dan cookies dalam konteks menyimpan state di aplikasi web?
    Kelebihan cookies 
    -Data disimpan di sisi client.
    -Cocok untuk informasi kecil (misalnya last_login).
    Kekurangan cookies
    -Kapasitas terbatas.
    -Mudah dimanipulasi jika tidak diamankan.

    Kelebihan Session
    -Data disimpan di server → lebih aman.
    -Bisa menyimpan data yang lebih kompleks.
    Kekurangan session
    -Membutuhkan penyimpanan server.
    -Jika tidak dikelola, bisa menambah beban server.

4. Apakah penggunaan cookies aman secara default dalam pengembangan web, atau apakah ada risiko potensial yang harus diwaspadai? Bagaimana Django menangani hal tersebut?
    Cookies tidak sepenuhnya aman secara bawaan, sehingga ada beberapa potensi risiko, seperti:
    -XSS (Cross-Site Scripting): cookie dapat dicuri melalui penyisipan script berbahaya.
    -Session hijacking: jika session ID yang tersimpan di cookie dicuri, penyerang bisa masuk sebagai pengguna sah.
    -Manipulasi data: karena cookie berada di sisi client, nilainya bisa diubah secara manual.

    Django mengantisipasi hal ini dengan cara:
    -Memberikan flag HttpOnly agar cookie tidak dapat diakses lewat JavaScript.
    -Menyediakan opsi Secure supaya cookie hanya dikirim melalui HTTPS.
    -Menggunakan CSRF token untuk melindungi request dari pemalsuan.
    -Mengandalkan Session framework, di mana data disimpan di server dan cookie hanya menyimpan ID session.
    
5. Jelaskan bagaimana cara kamu mengimplementasikan checklist di atas secara step-by-step (bukan hanya sekadar mengikuti tutorial)
    1. Tambahkan tiga view di views.py: register, login_user, dan logout_user. Gunakan UserCreationForm untuk pendaftaran dan AuthenticationForm untuk proses login.
    2. Siapkan template register.html dan login.html yang menampilkan form registrasi dan login.
    3. Daftarkan path/route di urls.py supaya ketiga view tersebut dapat diakses dari browser.
    4. Di models.py tambahkan relasi ke user pada model produk:
    user = models.ForeignKey(User, on_delete=models.CASCADE, null=True)
    lalu jalankan python manage.py makemigrations dan python manage.py migrate.
    5. Pada main.html tambahkan tombol Logout dan tampilkan informasi user yang sedang aktif ({{ user.username }}) serta nilai last_login.
    6. Saat membuat produk baru, set product.user = request.user sebelum memanggil product.save() agar produk tersambung ke akun pembuatnya.
    7. Buat dua akun melalui halaman register, lalu login ke masing-masing akun dan tambahkan 3 produk dummy per akun untuk pengujian.
    8. Saat login, simpan cookie last_login lewat response.set_cookie('last_login', str(datetime.datetime.now())); hapus cookie tersebut ketika melakukan logout.
    9. Pastikan view halaman utama (show_main) mem-filter query sehingga hanya menampilkan produk milik request.user (bukan semua produk).
    10. Commit perubahan ke git dan push ke repository GitHub (git add → git commit → git push).

    ----------------------------------------------------------------------------------
    Tugas 5
1. Jika terdapat beberapa CSS selector untuk suatu elemen HTML, jelaskan urutan prioritas pengambilan CSS selector tersebut!
    - Paling kuat → paling lemah: 
    1. Deklarasi dengan !important
    2. Inline style (mis. <h1 style="…">)
    3. ID selector (#id)
    4. Class / attribute / pseudo-class (.btn, [type="text"], :hover, :focus)
    5. Element / pseudo-element (h1, p, ::after)
    - Jika specificity sama, aturan yang ditulis paling akhir di file CSS yang diterapkan.


2. Mengapa responsive design menjadi konsep yang penting dalam pengembangan aplikasi web? Berikan contoh aplikasi yang sudah dan belum menerapkan responsive design, serta jelaskan mengapa!
    - Penting karena perangkat pengguna beragam (mobile, tablet, desktop) sehingga tampilan harus tetap terbaca, mudah diklik, dan tidak perlu geser horizontal.
    - Dampak positif: meningkatkan keterbacaan, pengalaman pengguna, SEO, dan konversi.
    - Contoh sudah responsif: Tokopedia, Gojek, Wikipedia (navigasi menyesuaikan; grid kolom berubah di layar kecil).
    - Contoh kurang responsif: situs lama berlebar tetap 960–1024 px atau halaman dengan tabel melebar tanpa pengaturan; di ponsel butuh zoom/geser sehingga sulit digunakan.


3. Jelaskan perbedaan antara margin, border, dan padding, serta cara untuk mengimplementasikan ketiga hal tersebut!

    - Margin: ruang di luar border untuk memisahkan elemen dari elemen lain.
    - Border: garis tepi yang membungkus elemen (antara padding dan margin).
    - Padding: ruang di dalam border untuk memberi jarak antara konten dan tepi.
    - Contoh:
    .kotak {
        margin: 16px;              /* ruang luar */
        border: 2px solid #e5e7eb; /* garis tepi */
        padding: 12px 16px;        /* ruang dalam (atas/bawah 12, kiri/kanan 16) */
    }
    - Catatan: margin vertikal dapat “collapse” (menyatu) antar blok; padding tidak.

4. Jelaskan konsep flex box dan grid layout beserta kegunaannya!
    - Flexbox: tata letak satu dimensi (baris ATAU kolom). Cocok untuk navbar, toolbar, baris tombol, atau deretan kartu yang bisa membungkus.
    Contoh singkat: 
        .toolbar { display:flex; justify-content:space-between; align-items:center; gap:8px; }
    - CSS Grid: tata letak dua dimensi (baris DAN kolom). Cocok untuk galeri/produk, dashboard, layout halaman.
    Contoh singkat:
        .grid-produk { display:grid; grid-template-columns:repeat(auto-fill, minmax(220px,1fr)); gap:16px; }
    - Inti beda: Flex fokus pada satu sumbu; Grid mengatur dua sumbu sekaligus.

5. Jelaskan bagaimana cara kamu mengimplementasikan checklist di atas secara step-by-step (bukan hanya sekadar mengikuti tutorial)!
    - Model & Form:
    - Pastikan model Product memiliki name, price, stock, image, description, (opsional) user.
    - Buat ProductForm (ModelForm) untuk validasi dan binding data.
    - Routing & Views:
    - Tambahkan URL list, detail/<id>, add, edit/<id>, delete/<id>.
    - Create/Edit: proses POST → valid → simpan; tampilkan umpan balik melalui messages.
    - Delete: sediakan halaman konfirmasi; hapus pada POST.
    - Lindungi aksi edit/hapus dengan login_required dan (bila ada) cek kepemilikan product.
    - UI & Desain:
    - Gunakan Tailwind (CDN) + global.css untuk gaya konsisten (input, fokus, spacing).
    - Navbar responsif: versi desktop menampilkan menu penuh; versi mobile memakai tombol hamburger.
    - Daftar produk:
        - Empty state: jika belum ada data, tampilkan ilustrasi + tombol “Tambah Produk”.
        - Card grid: jika ada data, tampilkan kartu berisi gambar, nama, harga, stok, ringkasan deskripsi.
        - Tiap kartu memiliki dua tombol: Edit dan Hapus (hapus via form POST + csrf + confirm).
    - Halaman form (Tambah/Edit): satu templat, menampilkan error per field agar mudah diperbaiki.
    - Halaman detail: gambar utama, harga (tegas), stok, deskripsi, serta tombol Edit/Hapus (bila berhak) dan Kembali.
    - Static & Media:
    - Atur MEDIA_URL dan MEDIA_ROOT agar unggah gambar produk berfungsi di pengembangan.
    - Simpan no-products.png pada static/image untuk empty state.
    - Uji & Rilis:
    - Uji pada berbagai lebar layar (DevTools → Toggle device).
    - Periksa aksesibilitas dasar (alt text, kontras, ukuran tombol).
    - Versi kontrol: git add → commit → push ke GitHub (opsional buka PR).


